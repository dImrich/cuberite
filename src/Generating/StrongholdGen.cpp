
// StrongholdGen.cpp

// Implements the cStrongholdGen class representing the stronghold generator

#include "Globals.h"
#include "StrongholdGen.h"
#include "PieceGeneratorBFSTree.h"
#include "../BlockInfo.h"
#include "../FastRandom.h"
#include "../World.h"





/*
How village generating works:
By descending from a cGridStructGen, a semi-random (jitter) grid is generated. A village may be generated for each
of the grid's cells. Each cell checks the biomes in an entire chunk around its center, only generating a village if
all biomes are village-friendly. If yes, the entire village structure is built for that cell. If not, the cell
is left village-less.

A village is generated using the regular BFS piece generator. The well piece is used as the starting piece,
the roads and houses are then used as the following pieces. Only the houses are read from the prefabs,
though, the roads are generated by code and their content is ignored. A special subclass of the cPiecePool
class is used, so that the roads connect to each other and to the well only in predefined manners.

The well has connectors of type "2". The houses have connectors of type "-1". The roads have connectors of
both types' opposites, type "-2" at the far ends and type "1" on the long edges. Additionally, there are
type "2" connectors along the long edges of the roads as well, so that the roads create T junctions.

When the village is about to be drawn into a chunk, it queries the heights for each piece intersecting the
chunk. The pieces are shifted so that their first connector lies on the surface, and the roads are drawn
directly by turning the surface blocks into gravel / sandstone.

The village prefabs are stored in global piecepools (one pool per village type). In order to support
per-village density setting, the cVillage class itself implements the cPiecePool interface, relaying the
calls to the underlying cVillagePiecePool, after processing the density check.
*/

class cStrongholdPiecePool:
	public cPrefabPiecePool
{
	using Super = cPrefabPiecePool;

public:

	cStrongholdPiecePool(
		const cPrefab::sDef * a_PieceDefs,         size_t a_NumPieceDefs,
		const cPrefab::sDef * a_StartingPieceDefs, size_t a_NumStartingPieceDefs
	):
		Super(a_PieceDefs, a_NumPieceDefs, a_StartingPieceDefs, a_NumStartingPieceDefs)
	{
		AddRoadPieces();
	}

	cStrongholdPiecePool(void)
	{
		AddRoadPieces();
	}

	void AddRoadPieces(void)
	{
		// Add the road pieces:
		for (int len = 27; len < 60; len += 12)
		{
			cBlockArea BA;
			BA.Create(len, 1, 3, cBlockArea::baTypes | cBlockArea::baMetas);
			BA.Fill(cBlockArea::baTypes | cBlockArea::baMetas, E_BLOCK_GRAVEL, 0);
			cPrefab * RoadPiece = new cPrefab(BA, 1);
			RoadPiece->AddConnector(0,       0, 1, cPiece::cConnector::dirXM, -2);
			RoadPiece->AddConnector(len - 1, 0, 1, cPiece::cConnector::dirXP, -2);
			RoadPiece->SetDefaultWeight(100);

			// Add the road connectors:
			for (int x = 1; x < len; x += 12)
			{
				RoadPiece->AddConnector(x, 0, 0, cPiece::cConnector::dirZM, 2);
				RoadPiece->AddConnector(x, 0, 2, cPiece::cConnector::dirZP, 2);
			}

			// Add the buildings connectors:
			for (int x = 7; x < len; x += 12)
			{
				RoadPiece->AddConnector(x, 0, 0, cPiece::cConnector::dirZM, 1);
				RoadPiece->AddConnector(x, 0, 2, cPiece::cConnector::dirZP, 1);
			}
			m_AllPieces.push_back(RoadPiece);
			m_PiecesByConnector[-2].push_back(RoadPiece);
			m_PiecesByConnector[1].push_back(RoadPiece);
			m_PiecesByConnector[2].push_back(RoadPiece);
		}  // for len - roads of varying length
	}


	// cPrefabPiecePool overrides:
	virtual int GetPieceWeight(const cPlacedPiece & a_PlacedPiece, const cPiece::cConnector & a_ExistingConnector, const cPiece & a_NewPiece) override
	{
		// Roads cannot branch T-wise (appending -2 connector to a +2 connector on a 1-high piece):
		if ((a_ExistingConnector.m_Type == 2) && (a_PlacedPiece.GetDepth() > 0) && (a_PlacedPiece.GetPiece().GetSize().y == 1))
		{
			return 0;
		}

		return static_cast<const cPrefab &>(a_NewPiece).GetPieceWeight(a_PlacedPiece, a_ExistingConnector);
	}
};





class cStrongholdGen::cStronghold:
	public cGridStructGen::cStructure,
	protected cPiecePool
{
	using Super = cGridStructGen::cStructure;

public:

	cStronghold(
		int a_Seed,
		int a_GridX, int a_GridZ,
		int a_OriginX, int a_OriginZ,
		int a_MaxRoadDepth,
		int a_MaxSize,
		int a_Density,
		cStrongholdPiecePool & a_Prefabs
	):
		Super(a_GridX, a_GridZ, a_OriginX, a_OriginZ),
		m_Seed(a_Seed),
		m_Noise(a_Seed),
		m_MaxSize(a_MaxSize),
		m_Density(a_Density),
		m_Borders(
			{a_OriginX - a_MaxSize, 0, a_OriginZ - a_MaxSize},
			{a_OriginX + a_MaxSize, cChunkDef::Height - 1, a_OriginZ + a_MaxSize}
		),
		m_Prefabs(a_Prefabs)
	{
		// Generate the pieces for this village; don't care about the Y coord:
		cPieceGeneratorBFSTree pg(*this, a_Seed);
		pg.PlacePieces(a_OriginX, a_OriginZ, a_MaxRoadDepth + 1, m_Pieces);
		if (m_Pieces.empty())
		{
			return;
		}
	}


protected:
	/** Seed for the random functions */
	int m_Seed;

	/** The noise used as a pseudo-random generator */
	cNoise m_Noise;

	/** Maximum size, in X / Z blocks, of the village (radius from the origin) */
	int m_MaxSize;

	/** The density for this village. Used to refrain from populating all house connectors. Range [0, 100] */
	int m_Density;

	/** Borders of the village - no item may reach out of this cuboid. */
	cCuboid m_Borders;

	/** Prefabs to use for buildings */
	cStrongholdPiecePool & m_Prefabs;

	/** The underlying height generator, used for placing the structures on top of the terrain. */
	cTerrainHeightGenPtr m_HeightGen;

	/** The village pieces, placed by the generator. */
	cPlacedPieces m_Pieces;


	// cGridStructGen::cStructure overrides:
	virtual void DrawIntoChunk(cChunkDesc & a_Chunk) override
	{

		// Iterate over all items
		// Each intersecting prefab is placed on ground, then drawn
		// Each intersecting road is drawn by replacing top soil blocks with gravel / sandstone blocks
		int iii = 0;
		for (cPlacedPieces::iterator itr = m_Pieces.begin(), end = m_Pieces.end(); itr != end; ++itr)
		{
			iii++;
			const cPrefab & Prefab = static_cast<const cPrefab &>((*itr)->GetPiece());
			if ((*itr)->GetPiece().GetSize().y == 1)
			{
				// It's a road, special handling (change top terrain blocks to
				// m_RoadBlock)
				DrawTunnel(a_Chunk, **itr);
				continue;
			}
			if (!(*itr)->HasBeenMovedToGround())
			{
				(*itr)->MoveToGroundBy(32 - (*itr)->GetCoords().y);
			}
			Prefab.Draw(a_Chunk, itr->get());
		}  // for itr - m_PlacedPieces[]
	}

	/** Draws the road into the chunk.
	The heightmap is not queried from the heightgen, but is given via parameter, so that it may be queried just
	once for all roads in a chunk. */
	void DrawTunnel(cChunkDesc & a_Chunk, cPlacedPiece & a_Road)
	{
		cCuboid RoadCoords = a_Road.GetHitBox();
		RoadCoords.Sort();
		int MinX = std::max(RoadCoords.p1.x - a_Chunk.GetChunkX() * cChunkDef::Width, 0);
		int MaxX = std::min(RoadCoords.p2.x - a_Chunk.GetChunkX() * cChunkDef::Width, cChunkDef::Width - 1);
		int MinZ = std::max(RoadCoords.p1.z - a_Chunk.GetChunkZ() * cChunkDef::Width, 0);
		int MaxZ = std::min(RoadCoords.p2.z - a_Chunk.GetChunkZ() * cChunkDef::Width, cChunkDef::Width - 1);

		for (int z = MinZ; z <= MaxZ; z++)
		{
			for (int x = MinX; x <= MaxX; x++)
			{
				
				
					a_Chunk.SetBlockTypeMeta(x, 32, z, E_BLOCK_STONE_BRICKS, 0);
					a_Chunk.SetBlockTypeMeta(x, 33, z, E_BLOCK_AIR, 0);
					a_Chunk.SetBlockTypeMeta(x, 34, z, E_BLOCK_AIR, 0);
					a_Chunk.SetBlockTypeMeta(x, 35, z, E_BLOCK_AIR, 0);
					a_Chunk.SetBlockTypeMeta(x, 36, z, E_BLOCK_STONE_BRICKS, 0);
				
			}
		}
	}


	// cPiecePool overrides:
	virtual cPieces GetPiecesWithConnector(int a_ConnectorType) override
	{
		return m_Prefabs.GetPiecesWithConnector(a_ConnectorType);
	}


	virtual cPieces GetStartingPieces(void) override
	{
		return m_Prefabs.GetStartingPieces();
	}


	virtual int GetPieceWeight(
		const cPlacedPiece & a_PlacedPiece,
		const cPiece::cConnector & a_ExistingConnector,
		const cPiece & a_NewPiece
	) override
	{
		// Check against the density:
		if (a_ExistingConnector.m_Type == 1)
		{
			const Vector3i & Coords = a_PlacedPiece.GetRotatedConnector(a_ExistingConnector).m_Pos;
			int rnd = (m_Noise.IntNoise3DInt(Coords.x, Coords.y, Coords.z) / 7) % 100;
			if (rnd > m_Density)
			{
				return 0;
			}
		}

		// Density check passed, relay to m_Prefabs:
		return m_Prefabs.GetPieceWeight(a_PlacedPiece, a_ExistingConnector, a_NewPiece);
	}


	virtual int GetStartingPieceWeight(const cPiece & a_NewPiece) override
	{
		return m_Prefabs.GetStartingPieceWeight(a_NewPiece);
	}


	virtual void PiecePlaced(const cPiece & a_Piece) override
	{
		//m_Prefabs.PiecePlaced(a_Piece);
	}


	virtual void Reset(void) override
	{
		m_Prefabs.Reset();
	}


	void MoveAllDescendants(cPlacedPieces & a_PlacedPieces, size_t a_Pivot, int a_HeightDifference)
	{
		size_t num = a_PlacedPieces.size();
		auto & Pivot = a_PlacedPieces[a_Pivot];
		for (size_t i = a_Pivot + 1; i < num; i++)
		{
			if (
				(a_PlacedPieces[i]->GetParent() == Pivot.get()) &&  // It is a direct dependant of the pivot
				!(static_cast<const cPrefab &>(a_PlacedPieces[i]->GetPiece())).ShouldMoveToGround()  // It attaches strictly by connectors
			)
			{
				a_PlacedPieces[i]->MoveToGroundBy(a_HeightDifference);
				MoveAllDescendants(a_PlacedPieces, i, a_HeightDifference);
			}
		}  // for i - a_PlacedPieces[]
	}
} ;





////////////////////////////////////////////////////////////////////////////////
// cStrongholdGen:

cStrongholdGen::cStrongholdGen(
	int a_Seed,
	int a_GridSize,
	int a_MaxOffset,
	int a_MaxDepth,
	int a_MaxSize,
	int a_MinDensity,
	int a_MaxDensity,
	cBiomeGenPtr a_BiomeGen,
	cTerrainHeightGenPtr a_HeightGen,
	int a_SeaLevel
) :
	Super(a_Seed, a_GridSize, a_GridSize, a_MaxOffset, a_MaxOffset, a_MaxSize, a_MaxSize, 100),
	m_RandNoise(a_Seed + 1000),
	m_MaxDepth(a_MaxDepth),
	m_MaxSize(a_MaxSize),
	m_MinDensity(a_MinDensity),
	m_MaxDensity(a_MaxDensity),
	m_BiomeGen(std::move(a_BiomeGen)),
	m_HeightGen(std::move(a_HeightGen))
{

	if (!m_PositionsGenerated)
	{
		GeneratePositions();
		m_PositionsGenerated = true;
		for (cChunkCoordsList::iterator itr = m_StrongholdPositions.begin();itr != m_StrongholdPositions.end(); ++itr)
		{
			printf("GEN!! ---- X: %d Z: %d ||||| \n", itr->m_ChunkX * 16, itr->m_ChunkZ * 16);
		}
		
	}

	
		auto prefabs = std::make_shared<cStrongholdPiecePool>();
		auto fileName = Printf("Prefabs%sPieceStructures%s%s.cubeset", cFile::GetPathSeparator().c_str(), cFile::GetPathSeparator().c_str(), "Stronghold");
		if (prefabs->LoadFromFile(fileName, true))
		{
			if (NoCaseCompare(prefabs->GetIntendedUse(), "stronghold") != 0)
			{
				LOGWARNING("Stronghold generator: File %s is intended for use in \"%s\", rather than strongholds. Loading the file, but the generator may behave unexpectedly.",
					fileName.c_str(), prefabs->GetIntendedUse().c_str()
				);
			}
			prefabs->AssignGens(a_Seed, m_BiomeGen, m_HeightGen, a_SeaLevel);
			m_Pools.push_back(std::move(prefabs));
		}
	
}





cGridStructGen::cStructurePtr cStrongholdGen::CreateStructure(int a_GridX, int a_GridZ, int a_OriginX, int a_OriginZ)
{
	// Generate the biomes for the chunk surrounding the origin:
	int ChunkX, ChunkZ;
	cChunkDef::BlockToChunk(a_OriginX, a_OriginZ, ChunkX, ChunkZ);
	cChunkDef::BiomeMap Biomes;
	m_BiomeGen->GenBiomes({ChunkX, ChunkZ}, Biomes);

	// Get a list of pools that support each biome within the chunk:
	// If just one column's biome is not allowed, the pool is not used because it's likely that an unfriendly biome is too close
	auto availablePools = m_Pools;
	for (size_t i = 0; i < ARRAYCOUNT(Biomes); i++)
	{
		auto biome = Biomes[i];
		availablePools.erase(std::remove_if(availablePools.begin(), availablePools.end(),
			[biome](std::shared_ptr<cStrongholdPiecePool> & a_Pool)
			{
				return !a_Pool->IsBiomeAllowed(biome);
			}),
			availablePools.end()
		);
		// Bail out if no compatible pools left:
		if (availablePools.empty())
		{
			return cStructurePtr();
		}
	}

	// Pick one pool from the available pools:
	if (availablePools.empty())
	{
		return cStructurePtr();
	}
	auto rnd = m_RandNoise.IntNoise2DInt(a_OriginX, a_OriginZ) / 11;
	auto pool = availablePools[static_cast<size_t>(rnd) % availablePools.size()];
	rnd /= 137;

	// Choose density for the village, random between m_MinDensity and m_MaxDensity:
	int Density;
	if (pool->GetMaxDensity() > pool->GetMinDensity())
	{
		Density = pool->GetMinDensity() + rnd % (pool->GetMaxDensity() - pool->GetMinDensity());
	}
	else
	{
		Density = pool->GetMinDensity();
	}

	printf("Create STRONGHOLD %d %d %d %d             ", a_GridX, a_GridZ, a_OriginX, a_OriginZ);

	// Create a village based on the chosen prefabs:
	return cStructurePtr(new cStronghold(m_Seed, a_GridX, a_GridZ, a_OriginX, a_OriginZ, m_MaxDepth, m_MaxSize, Density, *pool.get()));
}

void cStrongholdGen::GeneratePositions()
{
	double distance = 32.0;
	double spread = 3.0;

	int ringIndex = 0;
	int ringStrongholdIndex = 0;


	double d1 = m_RandNoise.IntNoise2DInRange(333, 0, 0, 1) * M_PI * 2.0;

	for (int i = 0; i < 3; i++)
	{
		double d0 = 4.0 * distance + distance * ringIndex * 6.0 + (m_RandNoise.IntNoise2DInRange(666, i, 0, 1) - 0.5) * distance * 2.5;
		int chunkX = round(cos(d1) * d0);
		int chunkZ = round(sin(d1) * d0);

		auto chunkCoords = cChunkCoords(chunkX, chunkZ);
		m_StrongholdPositions.push_back(chunkCoords);

		d1 += (M_PI * 2.0) / (double)spread;

		++ringStrongholdIndex;

		if (ringStrongholdIndex == spread)
		{
			++ringIndex;
			ringStrongholdIndex = 0;
			spread += 2 * spread / (ringIndex + 1);
			spread = std::min(spread, (double)m_StrongholdPositions.size() - i);

			d1 += m_RandNoise.IntNoise2DInRange(333, ringIndex, 0, 1) * M_PI * 2.0;
		}
	}

	
}


Vector3i cStrongholdGen::GetNearestStronghold(cWorld & a_World, Vector3i a_Pos)
{
	auto a_Noise = cNoise(a_World.GetSeed() + 1000);
	auto Positions = cStrongholdGen::GeneratePositions(a_Noise);

	double distanceTemp = 0.0;
	int strongholdIndex = 0;

	Vector3i strongholdPos;

	for (cChunkCoordsList::iterator itr = Positions.begin(); itr != Positions.end(); ++itr)
	{
		int BlockX = itr->m_ChunkX * cChunkDef::Width;
		int BlockZ = itr->m_ChunkZ * cChunkDef::Width;
		Vector3f a_Distance = Vector3d(BlockX, 32, BlockZ) - a_Pos;
		double Distance = a_Distance.Length();

		if (strongholdIndex == 0 || distanceTemp > Distance)
		{
			distanceTemp = Distance;
			strongholdPos = Vector3d(BlockX, 32, BlockZ);
		}
		strongholdIndex++;
	}

	return strongholdPos;
}

cChunkCoordsList cStrongholdGen::GeneratePositions(cNoise & a_Noise)
{

	double distance = 32.0;
	double spread = 3.0;

	int ringIndex = 0;
	int ringStrongholdIndex = 0;


	double d1 = a_Noise.IntNoise2DInRange(333, 0, 0, 1) * M_PI * 2.0;
	cChunkCoordsList strongholds;

	for (int i = 0; i < 3; i++)
	{
		double d0 = 4.0 * distance + distance * ringIndex * 6.0 + (a_Noise.IntNoise2DInRange(666, i, 0, 1) - 0.5) * distance * 2.5;
		int chunkX = round(cos(d1) * d0);
		int chunkZ = round(sin(d1) * d0);

		auto chunkCoords = cChunkCoords(chunkX, chunkZ);
		strongholds.push_back(chunkCoords);

		d1 += (M_PI * 2.0) / (double)spread;

		++ringStrongholdIndex;

		if (ringStrongholdIndex == spread)
		{
			++ringIndex;
			ringStrongholdIndex = 0;
			spread += 2 * spread / (ringIndex + 1);
			spread = std::min(spread, (double)strongholds.size() - i);

			d1 += a_Noise.IntNoise2DInRange(333, ringIndex, 0, 1) * M_PI * 2.0;
		}
	}

	return strongholds;
}

void cStrongholdGen::GenFinish(cChunkDesc & a_ChunkDesc)
{
	int ChunkX = a_ChunkDesc.GetChunkX();
	int ChunkZ = a_ChunkDesc.GetChunkZ();

	cStructurePtrs a_Structures;

	

	for (cChunkCoordsList::iterator itr = m_StrongholdPositions.begin(); itr != m_StrongholdPositions.end(); ++itr)
	{
		int MinBlockX = itr->m_ChunkX * cChunkDef::Width - m_MaxStructureSizeX - m_MaxOffsetX;
		int MinBlockZ = itr->m_ChunkZ * cChunkDef::Width - m_MaxStructureSizeZ - m_MaxOffsetZ;
		int MaxBlockX = itr->m_ChunkX * cChunkDef::Width + m_MaxStructureSizeX + m_MaxOffsetX + cChunkDef::Width - 1;
		int MaxBlockZ = itr->m_ChunkZ * cChunkDef::Width + m_MaxStructureSizeZ + m_MaxOffsetZ + cChunkDef::Width - 1;
		int MinGridX = MinBlockX / m_GridSizeX;
		int MinGridZ = MinBlockZ / m_GridSizeZ;
		int MaxGridX = (MaxBlockX + m_GridSizeX - 1) / m_GridSizeX;
		int MaxGridZ = (MaxBlockZ + m_GridSizeZ - 1) / m_GridSizeZ;
		int MinX = MinGridX * m_GridSizeX;
		int MaxX = MaxGridX * m_GridSizeX;
		int MinZ = MinGridZ * m_GridSizeZ;
		int MaxZ = MaxGridZ * m_GridSizeZ;
		int MaxChunkX = MaxBlockX / cChunkDef::Width;
		int MaxChunkZ = MaxBlockZ / cChunkDef::Width;
		int MinChunkX = MinBlockX / cChunkDef::Width;
		int MinChunkZ = MinBlockZ / cChunkDef::Width;

		if (ChunkX >= MinChunkX && ChunkX <= MaxChunkX &&
			ChunkZ >= MinChunkZ && ChunkZ <= MaxChunkZ
		)
		{
			// Walk the cache, move each structure that we want into a_Structures:
			for (cStructurePtrs::iterator itr = m_Cache.begin(), end = m_Cache.end(); itr != end;)
			{
				if (((*itr)->m_GridX == MinBlockX) &&
					((*itr)->m_GridZ == MinBlockZ))

				{
					// want
					a_Structures.push_back(*itr);
					itr = m_Cache.erase(itr);
				}
				else
				{
					// don't want
					++itr;
				}
			}	

			bool Found = false;
			for (cStructurePtrs::const_iterator itr = a_Structures.begin(), end = a_Structures.end(); itr != end; ++itr)
			{
				if (((*itr)->m_GridX == MinBlockX) && ((*itr)->m_GridZ == MinBlockZ))
				{
					Found = true;
					break;
				}
			}  // for itr - a_Structures[]

			if (!Found)
			{
				printf("Someone started generating stronghold! %d | %d \n", ChunkX, ChunkZ);

				cStructurePtr Structure = CreateStructure(MinBlockX, MinBlockZ, itr->m_ChunkX*cChunkDef::Width, itr->m_ChunkZ*cChunkDef::Width);
				if (Structure.get() != nullptr)
				{
					a_Structures.push_back(Structure);
				}
				else
				{
					printf("null structure");
				}
			}
				
		}
	}
	
	// Copy a_Forts into m_Cache to the beginning:
	cStructurePtrs StructuresCopy(a_Structures);
	m_Cache.splice(m_Cache.begin(), StructuresCopy, StructuresCopy.begin(), StructuresCopy.end());

	// Trim the cache if it's too long:
	size_t CacheSize = 0;
	for (cStructurePtrs::iterator itr = m_Cache.begin(), end = m_Cache.end(); itr != end; ++itr)
	{
		CacheSize += (*itr)->GetCacheCost();
		if (CacheSize > m_MaxCacheSize)
		{
			// Erase all items from this one till the cache end
			m_Cache.erase(itr, m_Cache.end());
			break;
		}
	}

	//GetStructuresForChunk(ChunkX, ChunkZ, a_Structures);

	for (cStructurePtrs::const_iterator itr = a_Structures.begin(); itr != a_Structures.end(); ++itr)
	{
		(*itr)->DrawIntoChunk(a_ChunkDesc);
	}  // for itr - Structures[]
}
